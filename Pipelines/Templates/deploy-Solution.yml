# This is a deployment template referenced from build-deploy-Solution.yml

# build-deploy-Solution.yml calls this template twice, passing different connection information for test vs prod
parameters:
- name: serviceConnection
  type: string
- name: environmentVariables
  type: string
- name: connectionReferences
  type: string
- name: aadGroupTeamConfiguration
  type: string
- name: aadGroupCanvasConfiguration
  type: string
- name: solutionComponentOwnershipConfiguration
  type: string
- name: importUnmanaged
  type: string
  default: 'false'
- name: overwriteUnmanagedCustomizations
  type: string
  default: 'true'

steps:
- checkout: none

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.tool-installer.PowerPlatformToolInstaller@0
  displayName: 'Install Power Platform Build Tools'

# TEMPORARY: using Power DevOps Tools to supplement official Power Platform Build Tools until they have tasks which enable the same scenarios.
# https://marketplace.visualstudio.com/items?itemName=WaelHamze.xrm-ci-framework-build-tasks
- task: WaelHamze.xrm-ci-framework-build-tasks.MSCRMToolInstaller.MSCRMToolInstaller@12
  displayName: 'Power DevOps Tool Installer'

- template: install-powershell-modules.yml

# Other tasks, which use the PowerApps PowerShell cmdlets, need the environment guid.  Setting it for future use.
- template: set-environment-id.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'

# Other tasks, in this pipeline need to know if the solution already exists. Setting it for future use.
- template: set-solution-exists.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'

# Get the solution package from artifact uploaded by the build pipeline
- task: DownloadPipelineArtifact@2
  displayName: 'Download Build Pipeline Artifact'

# If called from import-unmanaged-to-dev-environment.yml, this task will run to deploy an unmanaged solution
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Unmanaged Solution'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: '$(UnmanagedSolutionPath)'
    PublishWorkflows: true
  condition: and(succeeded(), eq('${{parameters.importUnmanaged}}', 'true'))

- powershell: |
   $managedSolutionPath = ''
   $buildDropExists = 'false'
   If (Test-Path -Path "$(Pipeline.Workspace)/buildPipeline/drop")
   {
       $buildDropExists = 'true'
       #Attempt to find the managed solution in the build pipeline drop if build and deploy are seperate pipelines
       Get-ChildItem -Path "$(Pipeline.Workspace)/buildPipeline/drop" -Filter "$(SolutionName)*.zip" | 
       ForEach-Object {
           If ($_.FullName.Contains("_managed")) 
           { 
             $managedSolutionPath = $_.FullName 
           }
       }
   }
   If ($managedSolutionPath -eq '')
   {
        #Default to managed solution path in the same pipeline if using build-deploy-Solution.yml
        $managedSolutionPath = '$(Pipeline.Workspace)/drop/$(SolutionName)_$(Build.BuildNumber)_managed.zip'
   }
   Write-Host "##vso[task.setVariable variable=ManagedSolutionPath]$managedSolutionPath"
   Write-Host "##vso[task.setVariable variable=BuildDropExists]$buildDropExists"
   Write-Host $managedSolutionPath
  displayName: 'Get managed solution zip path'
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'))

- powershell: |    
    echo "##vso[task.setvariable variable=TriggerSolutionUpgrade;isOutput=true]false"

    # In order to determine if we need to perform a Solution Upgrade, we see if the Pull Request has a label of solution-upgrade on it.
    # The only way we know how to determine if the PR that created the commit for the branch had a label is to use the REST API

    if ("$(Build.Reason)" -ne "PullRequest") { 
      Write-Host "Provider-$(Build.Repository.Provider)"
      
      if("$(Build.Repository.Provider)" -eq "TfsGit") {      
        $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
        $headers.Add("Authorization", "Bearer $env:SYSTEM_ACCESSTOKEN")
        $headers.Add("Content-Type", "application/json")

        $buildSourceVersion = "$(Build.SourceVersion)"
        Write-Host $buildSourceVersion

        $pullrequestqueryBody = "{
        `n  `"queries`": [
        `n    {
        `n      `"type`": `"lastMergeCommit`",
        `n      `"items`": [ `"$buildSourceVersion`" ]
        `n    }
        `n  ]
        `n}"

        $pullrequestqueryBodyResourceUrl = "$(System.TeamFoundationCollectionUri)$(System.TeamProjectId)/_apis/git/repositories/$(Build.Repository.Name)/pullrequestquery?api-version=6.0"
        Write-Host $pullrequestqueryBodyResourceUrl

        $pullrequestqueryResponse = Invoke-RestMethod $pullrequestqueryBodyResourceUrl -Method 'POST' -Headers $headers -Body $pullrequestqueryBody 

        $pullrequestqueryResponseResults = $pullrequestqueryResponse.results
        Write-Host $pullrequestqueryResponseResults
        
        if ($pullrequestqueryResponseResults.Count -gt 0) {
          Write-Host "response.results not null"
          $pullRequestId = $pullrequestqueryResponseResults.$buildSourceVersion.pullRequestId
          $pullRequestLabelQuery = "$(System.TeamFoundationCollectionUri)$(System.TeamProjectId)/_apis/git/repositories/$(Build.Repository.Name)/pullRequests/$pullRequestId/labels?api-version=6.0"
          Write-Host $pullRequestLabelQuery

          $pullRequestLabelQueryResponse = Invoke-RestMethod -Uri $pullRequestLabelQuery -Method Get -Headers @{
            Authorization = "Bearer $env:SYSTEM_ACCESSTOKEN"
          }

          $pullRequestLabelQueryResponseValue = $pullRequestLabelQueryResponse.value
          
          if ($pullRequestLabelQueryResponseValue.Count -gt 0) {
            Write-Host "response.value not null"
            $triggerSolutionUpgrade = $pullRequestLabelQueryResponseValue.name.Contains('solution-upgrade').ToString().ToLower()
            Write-Host $triggerSolutionUpgrade
            echo "##vso[task.setvariable variable=TriggerSolutionUpgrade;isOutput=true]$triggerSolutionUpgrade"
          }
        }
      }
      
      if("$(Build.Repository.Provider)" -eq "GitHub") {
        # Placeholder for alternative logic when GitHub is the backing repo
        Write-Host "GitHub is the backing repo"
      }
    }
  name: setTriggerSolutionUpgrade
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
  displayName: 'Set TriggerSolutionUpgrade Variable'

# If the TriggerSolutionUpgrade variable is false, then import the solution as an Update
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Managed Solution as Update'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: $(ManagedSolutionPath)
    PublishWorkflows: true
    OverwriteUnmanagedCustomizations: ${{parameters.overwriteUnmanagedCustomizations}}
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'), or(eq(variables['setTriggerSolutionUpgrade.TriggerSolutionUpgrade'], 'false'), eq(variables['SolutionExists'], 'False')))

# If the TriggerSolutionUpgrade variable is true, then import the solution as an Upgrade, staging it as a holding solution, so we can apply a solution Upgrade.
# Doing this will ensure that items removed from the solution in development are also removed from the solution in the target environment after the Upgrade is applied.
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.import-solution.PowerPlatformImportSolution@0
  displayName: 'Import Managed Solution as Upgrade'
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionInputFile: $(ManagedSolutionPath)
    HoldingSolution: true
    OverwriteUnmanagedCustomizations: ${{parameters.overwriteUnmanagedCustomizations}}
  condition: and(succeeded(), ne('${{parameters.importUnmanaged}}', 'true'), eq(variables['setTriggerSolutionUpgrade.TriggerSolutionUpgrade'], 'true'), eq(variables['SolutionExists'], 'True'))

# NOTE: Sometimes you need to perform intermediary steps between staging the upgrade and applying it.  
# An example would be moving data from one entity to another before deleting the entity.
# You would add steps to your pipeline here to accomplish this. 

# If the TriggerSolutionUpgrade variable is true,then apply the solution Upgrade.
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.apply-solution-upgrade.PowerPlatformApplySolutionUpgrade@0
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
    SolutionName: '$(SolutionName)'
    AsyncOperation: true
  condition: and(succeeded(), eq(variables['setTriggerSolutionUpgrade.TriggerSolutionUpgrade'], 'true'), eq(variables['SolutionExists'], 'True'))

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.publish-customizations.PowerPlatformPublishCustomizations@0
  displayName: 'Power Platform Publish Customizations '
  inputs:
    authenticationType: PowerPlatformSPN
    PowerPlatformSPN: '${{parameters.serviceConnection}}'
  condition: and(succeeded(), eq('${{parameters.importUnmanaged}}', 'true'))
  # Only publish customizations for when importing unmanaged solutions into a dev environment.

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outEnvironmentVariables;isOutput=true]${{parameters.environmentVariables}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outEnvironmentVariables;isOutput=true]"
    }
  name: setEnvironmentVariablesOutput
  displayName: 'Set Environment Variables for Condition'

# WORKAROUND: We were using parameters in the condition, but it was not evaluating.  Reviewed: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=yaml#use-a-template-parameter-as-part-of-a-condition
# Current workaround is to set an output variable in the step above and use that in the condition below.
# Not sure this is the best way, but it works.
# Replace with official task when available
- task: WaelHamze.xrm-ci-framework-build-tasks.MSCRMUpdateEnvironmentVariables.MSCRMUpdateEnvironmentVariables@12
  displayName: 'Update Environment Variables'
  inputs:
    crmConnectionString: '$(CdsBaseConnectionString)${{parameters.serviceConnection}}'
    environmentVariablesJson: '${{parameters.environmentVariables}}'
  condition: and(succeeded(), ne(variables['setEnvironmentVariablesOutput.outEnvironmentVariables'], ''))

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outConnectionReferences;isOutput=true]${{parameters.connectionReferences}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outConnectionReferences;isOutput=true]"
    }

  name: setConnectionReferencesOutput
  displayName: 'Set Connection References for Condition'

- template: update-connection-references.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    connectionReferences: '${{parameters.connectionReferences}}'

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outAadGroupTeamConfiguration;isOutput=true]${{parameters.aadGroupTeamConfiguration}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outAadGroupTeamConfiguration;isOutput=true]"
    }
  name: setAadGroupTeamConfigurationOutput
  displayName: 'Set AAD Group Team Configuration for Condition'

- template: set-dataverse-aad-group-teams.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    aadGroupTeamConfiguration: '${{parameters.aadGroupTeamConfiguration}}'

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outAadGroupCanvasConfiguration;isOutput=true]${{parameters.aadGroupCanvasConfiguration}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outAadGroupCanvasConfiguration;isOutput=true]"
    }
  name: setAadGroupCanvasConfigurationOutput
  displayName: 'Set AAD Group Canvas Configuration for Condition'

- template: share-canvas-app-with-aad-group.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    aadGroupCanvasConfiguration: '${{parameters.aadGroupCanvasConfiguration}}'

- powershell: |
    # The try / catch below isn't ideal. However, passing runtime variables as parameters, which should resolve to empty strings if they don't exist, don't work as expected in AzDO. Runtime variables passed as strings 
    # are sent over with their variable name as opposed to their value. Only variables referenced with macro notation seem to resolve properly.
    $ErrorActionPreference = "Stop"
    Try
    {
      echo "##vso[task.setvariable variable=outSolutionComponentOwnershipConfiguration;isOutput=true]${{parameters.solutionComponentOwnershipConfiguration}}"
    }
    Catch 
    {
        echo "##vso[task.setvariable variable=outSolutionComponentOwnershipConfiguration;isOutput=true]"
    }
  name: setSolutionComponentOwnershipConfigurationOutput
  displayName: 'Set Solution Component Ownership Configuration for Condition'

- template: update-solution-component-ownership.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
    solutionComponentOwnershipConfiguration: '${{parameters.solutionComponentOwnershipConfiguration}}'

- template: import-configuration-migration-data.yml
  parameters:
    serviceConnection: '${{parameters.serviceConnection}}'
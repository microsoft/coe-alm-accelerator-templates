#This template builds a solution from source control. Once the solution is built deploy-Solution.yml can be called to deploy from the asset built here
parameters:
- name: buildType
  type: string
  default: 'Both'
- name: serviceConnectionName
  type: string
- name: serviceConnectionUrl
  type: string
- name: solutionName
  type: string
- name: skipBuildToolsInstaller
  type: string
  default: 'false'

steps:  
- template: set-service-connection-url.yml
  parameters:
    serviceConnectionName: '${{parameters.serviceConnectionName}}'
    serviceConnectionUrl: '${{parameters.serviceConnectionUrl}}'

- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.tool-installer.PowerPlatformToolInstaller@2
  displayName: 'Install Power Platform Build Tools'
  condition: and(succeeded(), eq('${{parameters.skipBuildToolsInstaller}}', 'false'))

# Use set-connection-variables task to get values from AzDO Service Connection to be used in scripts that don't use tasks
- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.set-connection-variables.PowerPlatformSetConnectionVariables@2
  displayName: 'Set Connection Variables'
  name: buildConnectionVariables
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '${{parameters.serviceConnectionName}}'

- template: set-spn-token.yml
  parameters:
    serviceConnection: ${{parameters.serviceConnectionUrl}}
    tenantId: $(buildConnectionVariables.BuildTools.TenantId)
    clientId: $(buildConnectionVariables.BuildTools.ApplicationId)
    clientSecret: $(buildConnectionVariables.BuildTools.ClientSecret)

- pwsh: |
    . "$env:POWERSHELLPATH/load-save-pipeline-parameters.ps1"
    Write-Build-Pipeline-Parameters "$(Agent.BuildDirectory)\build-pipeline-parameters.json" "${{parameters.buildType }}" "${{parameters.serviceConnectionName }}" "${{parameters.serviceConnectionUrl }}" "${{parameters.solutionName }}"
  displayName: 'Saving Build Pipeline Parameters'

- template: Hooks\build-solution-pre-hook.yml

# Set pipeline vars for tools paths.
- template: set-tools-paths.yml
    
- pwsh: |
    $splitName = "$(Build.Repository.Name)".Split("/")
    $repoName = $splitName[$splitName.Length - 1]
    Write-Host "##vso[task.setvariable variable=RepoName]$repoName"
  displayName: 'Set Source Repo Name'
  condition: and(succeeded(), ne('${{parameters.buildType}}', 'Unmanaged'))

- template: Hooks\build-solution-manipulate-source-pre-hook.yml

- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      set-pac-tools-path "$(Agent.OS)"
  displayName: 'Set pac tools path'

- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      pac-authenticate "${{parameters.serviceConnectionUrl}}" "$(buildConnectionVariables.BuildTools.ApplicationId)" "$(buildConnectionVariables.BuildTools.ClientSecret)" "$(buildConnectionVariables.BuildTools.TenantId)" "$(pacPath)"
  displayName: 'Pac cli and Authenticate'

- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      restructure-legacy-folders '$(Build.ArtifactStagingDirectory)' '$(Build.SourcesDirectory)' '$(RepoName)' '${{parameters.solutionName}}' '$(pacPath)' '${{parameters.serviceConnectionUrl}}' '$(Agent.BuildDirectory)'
  displayName: 'Restructure legacy folders'
  
# Solution version in source control is not used.  Instead, create version at build time from the current build number.
- pwsh: |
   $solutionXMLPath = "$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\src\Other\Solution.xml"
    . "$env:POWERSHELLPATH/build-deploy-solution-functions.ps1"
   update-solution-xml-with-build-number "$solutionXMLPath" "$(Build.BuildNumber)"
  displayName: 'Update Solution XML with Build Number'
  condition: and(succeeded(), ne('${{parameters.buildType}}', 'Unmanaged'))

# Before we committed changes, we formatted all json files for readability in source control.  This breaks solution package, so we need to flatten them before packing   
- pwsh: |
    #When we unpack the solution files, we format the json, but it causes solution import failures so we need to flatten the files
    $solutionFolderPath = "$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}"
    . "$env:POWERSHELLPATH/build-deploy-solution-functions.ps1"
    flatten-JSON-files "$solutionFolderPath"
  displayName: 'Flatten JSON files'
  enabled: true

# Pack canvas app source files into msapp
- pwsh: |
   . "$env:POWERSHELLPATH/build-deploy-solution-functions.ps1"
    Process-old-canvas-code-folder-structure "$(Build.SourcesDirectory)" "$(RepoName)" "${{parameters.solutionName}}" "$(Agent.OS)" "$(Agent.TempDirectory)"
  displayName: 'Detect and process old canvas code folder structure for backwards compatibility'
  workingDirectory: $(PowerShellPath)
  enabled: true
  
# Set paths to deployment settings
- template: set-deployment-configuration-paths.yml
  parameters:
    configPath: '$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\config\'
    environmentName: '$(EnvironmentName)'

# We'll store configuration data as artifacts on the build pipeline to be used during deployment. This includes configuration data created via Configuration data migration tool and deploymentSettings.json and customDeploymentSettings.json 
- pwsh: |
    . "$env:POWERSHELLPATH/archive-configuration-migration-data.ps1"
    Invoke-ArchiveConfigurationMigrationData '$(Build.SourcesDirectory)' '$(Build.ArtifactStagingDirectory)' '$(RepoName)' '${{parameters.solutionName}}'
  displayName: 'Archive Configuration Migration Data'
  
# Third party task to replace tokens in files. The FileTransform above replaces JSON tokens based on their path as opposed to replacing text tokens in a file which can be more error prone in some cases.
# If you aren't using this task it can be safely removed or disabled by setting enabled: false. Sample token: #{VariableNameToReplace}#
- task: qetza.replacetokens.replacetokens-task.replacetokens@3
  displayName: 'Replace Tokens: deploymentSettings.json'
  inputs:
    rootDirectory: $(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\config\
    targetFiles: '**\*deploymentSettings*.json'
    actionOnMissing: 'silently continue'
    writeBOM: false
    encoding: 'utf-8'
    defaultValue: ''
  condition: and(succeeded(), or(ne(variables['DeploymentSettingsPath'], ''), ne(variables['CustomDeploymentSettingsPath'], '')))
  enabled: true

# Set deployment variable for Activate Flow Configuration
- template: set-deployment-variable.yml
  parameters:
    variableName: 'outActivateFlows'
    deploymentSettingsPath: $(CustomDeploymentSettingsPath)
    deploymentSettingsNode: 'ActivateFlowConfiguration'
    displayName: 'Retrieve Flow Activation Config for Build'

# Enabled or Disable Flows in the Solution based on configuration
- template: enable-disable-solution-flows.yml
  parameters:
    buildSourceDirectory: '$(Build.SourcesDirectory)'
    repo: '$(RepoName)'
    solutionName: '${{parameters.solutionName}}'
    disableAllFlows: 'false'
    activateFlowConfiguration: '$(outActivateFlows)'

- pwsh: |
    # Default to true when no variable is set on the pipeline
    if ('$(ProcessCanvasApps)'.Contains("ProcessCanvasApps")){
      echo '##vso[task.setvariable variable=localProcessCanvasApps]true'
    }
    else {
      echo '##vso[task.setvariable variable=localProcessCanvasApps]$(ProcessCanvasApps)'
    }    
  displayName: 'Set localProcessCanvasApps variable'

- template: Hooks\build-solution-pack-pre-hook.yml

- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      check-code-first-components '$(Build.SourcesDirectory)' '$(RepoName)' '${{parameters.solutionName}}'
  displayName: 'Check codefirst components existence'

- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      add-codefirst-projects-to-cdsproj '$(Build.SourcesDirectory)' '$(RepoName)' '${{parameters.solutionName}}' '$(pacPath)'
  displayName: 'Add project references to cdsproject'

- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      pcf-Projects-install-npm '$(Build.SourcesDirectory)' '$(RepoName)'
  displayName: 'Install npm - pcf projects'

- task: VSBuild@1
  inputs:
    #solution: '$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\${{parameters.solutionName}}\${{parameters.solutionName}}.cdsproj'
    solution: '$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\${{parameters.solutionName}}.cdsproj'
    msbuildArgs: '/t:build /restore'
    #platform: '$(buildPlatform)'
    #configuration: '$(buildConfiguration)'
  displayName: 'Build cdsproject'

- task: VSTest@2
  inputs:
    platform: 'Any CPU'
    configuration: 'Release'
    codeCoverageEnabled: True
    resultsFolder: '$(build.ArtifactStagingDirectory)\Test\Results'
    searchFolder: '$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}'
    testAssemblyVer2: |
      **\*test*.dll
      !**\*TestAdapter.dll
      !**\obj\**
    condition: and(succeeded(), eq(variables.pluginstestexists, 'true'))
  displayName: 'Run unit test case projects'

- pwsh: |
    $sourceDirectory  = "$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\bin\Debug\*"
    Get-ChildItem "$sourceDirectory" -Recurse
  displayName: 'Display Bin Files' 

  # Using cdsproj approach Solutions gets created post building cdsproj file.
  # Copy the Solution from bin to ArtifactStagingDirectory
- pwsh: |
    #$sourceDirectory  = "$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\${{parameters.solutionName}}\bin\Debug\*"
    $sourceDirectory  = "$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\bin\Debug\*"
    $destinationDirectory = "$(Build.ArtifactStagingDirectory)"
    If(Test-Path "$sourceDirectory")
    {
        Copy-item -Force -Recurse -Verbose "$sourceDirectory" -Destination $destinationDirectory
    }
    else
    {
        Write-Host "Folder unavailable - $sourceDirectory"
    }
  displayName: 'Copy cdsproj solutions to ArtifactStagingDirectory'
  
- pwsh: |
      . "$env:POWERSHELLPATH/code-first-functions.ps1"
      append-version-to-solutions '$(Build.ArtifactStagingDirectory)' '${{parameters.solutionName}}' '$(Build.BuildNumber)'
  displayName: 'Append version to solutions'  

- pwsh: |
    Get-ChildItem "$(Build.ArtifactStagingDirectory)"
  displayName: 'Print ArtifactStagingDirectory Files'

#Run Solution Checker against our solution. This is currently only triggered for pipelines that trigger for Pull Requests
#- task: microsoft-IsvExpTools.PowerPlatform-BuildTools.checker.PowerPlatformChecker@2
#  displayName: 'Run Solution Checker'
#  inputs:
#    authenticationType: PowerPlatformSPN
#    PowerPlatformSPN: ${{parameters.serviceConnectionName}}
#    FilesToAnalyze: '$(Build.ArtifactStagingDirectory)\${{parameters.solutionName}}_$(Build.BuildNumber).zip'
#    RuleSet: '0ad12346-e108-40b8-a956-9a8f95ea18c9'
#  condition: and(succeeded(), and(ne(variables['DisableSolutionChecker'], 'true'), eq(variables['Build.Reason'], 'PullRequest')))

- task: PublishPipelineArtifact@1
  displayName: 'Publish Artifacts'
  inputs:
    targetPath: '$(Build.ArtifactStagingDirectory)'
    artifact: drop

- template: Hooks\build-solution-post-hook.yml
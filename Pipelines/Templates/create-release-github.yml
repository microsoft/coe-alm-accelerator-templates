#Template to create releases in Github based on defined milestones for Month/Year
parameters:
- name: gitHubApiUrl
  type: string
- name: solutionName
  type: string
- name: solutionDisplayName
  type: string
- name: releaseMonth
  type: number
- name: releaseYear
  type: number
- name: connectionName
  type: string
- name: releaseNotesPath
  type: string
- name: closeIssues
  type: string
- name: issueClosingComment
  type: string
  default: ''
- name: isDraft
  type: boolean
  default: true
- name: isPreRelease
  type: boolean
  default: false
- name: hotfixReleaseNumber
  type: number
  default: 0
- name: queryHeadingDelimited
  type: string
  default: "|"
- name: prepareAppSourcePackage
  type: boolean
  default: false
- name: preparePackageDeployerPackage
  type: boolean
  default: false
- name: projectName
  type: string
- name: packageConfigurationFilePath
  type: string
  default: ''

steps:
# Enable system diagnostics for detailed logging
- task: PowerShell@2
  displayName: 'Enable system.debug'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Enabling system.debug"
  env:
    SYSTEM_DEBUG: true

# Checkout Tools Repo
- checkout: Self

# Checkout ALM Repo
- checkout: PipelineRepo
  path: 'PipelineUtils'
  displayName: 'Checkout Pipeline Branch'
  
#This step will read the release notes into a variable and append a list of issues based on the milestone defined by:
#'${{ parameters.solutionDisplayName }} - ${{ parameters.releaseMonth }} ${{ parameters.releaseYear }}'
#Example Milestone 'CoE Starter Kit - July 2021'
#If a milestone with the specific name is not found an error will be thrown
- pwsh: |
    try{
            #Convert release month number to name
            $releaseMonthName = (Get-Culture).DateTimeFormat.GetMonthName(${{ parameters.releaseMonth }})
            Write-Host "##vso[task.setvariable variable=ReleaseMonthName]$releaseMonthName"
            $releaseMonthPadded = ([string]${{parameters.releaseMonth}}).PadLeft(2,'0')
            $fullReleaseNotesPath = '${{ parameters.releaseNotesPath }}/${{parameters.solutionName}}/RELEASENOTES-${{parameters.releaseYear}}' + $releaseMonthPadded + '.md'
            Write-Host "FullReleaseNotesPath - $fullReleaseNotesPath"
            $releaseNotes = ''
            if(Test-Path $fullReleaseNotesPath) {
                $releaseNotes = Get-Content $fullReleaseNotesPath -Raw
                Write-Host "Path found. Content - $releaseNotes"
            }
            else {
                $fullReleaseNotesPath = '${{ parameters.releaseNotesPath }}/${{parameters.solutionName}}/RELEASENOTES.md'
                if(Test-Path $fullReleaseNotesPath) {
                    $releaseNotes = Get-Content $fullReleaseNotesPath -Raw
                }
                else
                {
                    New-Item $fullReleaseNotesPath
                }
            }
            Write-Host "##vso[task.setvariable variable=ReleaseNotesPath]$fullReleaseNotesPath"
            $releaseNotes = $releaseNotes + [Environment]::NewLine + '## Change Log'

            #Set the tag and title for the release
            $tag = '${{ parameters.solutionName }}-$(ReleaseMonthName)${{ parameters.releaseYear }}'
            $title = '${{ parameters.solutionDisplayName }} $(ReleaseMonthName) ${{ parameters.releaseYear }}'
            if(${{parameters.HotfixReleaseNumber}} -ne 0) {
                $tag = '${{ parameters.solutionName }}-$(ReleaseMonthName)${{ parameters.releaseYear }}-HF${{parameters.HotfixReleaseNumber}}'
                $title = '${{ parameters.solutionDisplayName }} $(ReleaseMonthName) ${{ parameters.releaseYear }} - Hotfix ${{parameters.HotfixReleaseNumber}}'
            }

            Write-Host "##vso[task.setvariable variable=Tag]$tag"
            Write-Host "##vso[task.setvariable variable=Title]$title"

            $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
            $headers.Add("Accept", "application/vnd.github.groot-preview+json")
            $headers.Add("Authorization", "Bearer $(GitHubPAT)")

            #Find the milestone for this release e.g. 'CoE Starter Kit - July 2021
            $milestoneRequest = "https://api.github.com/repos/${{ parameters.gitHubApiUrl }}/milestones?sort=due_on&direction=desc"
            Write-Host "MilestoneRequest - $milestoneRequest"
            #Write-Host "Calling using curl"
            #$response = Invoke-Expression "curl -i https://api.github.com/repos/microsoft/powercat-business-approvals-kit/milestones"
            #Write-Host "Curl response - "$response

            $milestoneResponse = Invoke-RestMethod $milestoneRequest -Method 'GET' -Headers $headers
            $currentMilestone = $null
            $milestoneName = '${{ parameters.solutionDisplayName }} - ' + $releaseMonthName + ' ' + ${{ parameters.releaseYear }}
            foreach($milestone in $milestoneResponse){
                if($milestone.title -eq $milestoneName){
                    $currentMilestone = $milestone
                    break
                }
            }
            

            Write-Host "CurrentMilestone - $currentMilestone"
            #Build the release notes
            if($currentMilestone -ne $null){
                $queryHeadings = "${{parameters.queryHeadingDelimited}}".split('|')
                Write-Host "QueryHeadings - $queryHeadings"
                for ($i = 0; $i -lt $queryHeadings.Length; $i = $i+2) {
                    #Only retrieve closed issues in this milestone
                    $issuesRequestUrl = 'https://api.github.com/search/issues?per_page=100&sort=created&order=asc&q=is:issue repo:${{ parameters.gitHubApiUrl }} milestone:"' + $currentMilestone.title + '"'
                    if(-not [string]::IsNullOrWhiteSpace($queryHeadings[$i])) {
                        $issuesRequestUrl = $issuesRequestUrl + " " + $queryHeadings[$i]
                    }
                    Write-Host "IssuesRequestUrl - $issuesRequestUrl"
                    $issueResponse = Invoke-RestMethod $issuesRequestUrl -Method 'GET' -Headers $headers

                    if($issueResponse.items.Length -gt 0 -and -not [string]::IsNullOrWhiteSpace($queryHeadings[$i + 1])) {
                        $releaseNotes = [Environment]::NewLine + $releaseNotes + [Environment]::NewLine + $queryHeadings[$i + 1] + " (" + $issueResponse.items.Length + ")"
                    }
                    foreach($issue in $issueResponse.items){
                        if("${{ parameters.closeIssues }}" -eq "True") {
                            if('${{ parameters.issueClosingComment }}' -ne '') {
                                # Add the comment to the issue
                                # /repos/{owner}/{repo}/issues/{issue_number}/comments
                                $commentRequestUrl = "https://api.github.com/repos/${{ parameters.gitHubApiUrl }}/issues/" + $issue.number + "/comments"
                                $commentFormatted = "@" + $issue.user.login + " ${{ parameters.issueClosingComment }}"
                                $commentBody = "{`"body`": `"$commentFormatted`"}"
                                Write-Host "CommentRequestUrl - $commentRequestUrl"
                                Invoke-RestMethod $commentRequestUrl -Method 'POST' -Headers $headers -Body $commentBody
                            }

                            # Close the issue if not closed
                            if($issue.state -ne 'closed') {
                                #/repos/{owner}/{repo}/issues/{issue_number}
                                $issueRequestClosingUrl = "https://api.github.com/repos/${{ parameters.gitHubApiUrl }}/issues/" + $issue.number
                                $closeRequestBody = "{`"state`": `"closed`"}"
                                Write-Host "IssueRequestClosingUrl - $issueRequestClosingUrl"
                                Invoke-RestMethod $issueRequestClosingUrl -Method 'PATCH' -Headers $headers -Body $closeRequestBody
                            }
                        }
                        $releaseNotes = $releaseNotes + [Environment]::NewLine + "  - #" + $issue.number + "-" + $issue.title #Add a line for each issue with number and title. Add more here as necessary
                    }
                }
                Set-Content -Path $fullReleaseNotesPath -Value $releaseNotes

                exit 0
            }
    }
    catch {
        # Suppress the error
        Write-Host "An error occurred. Message - $($_.Exception.Message)"
    }
  displayName: Build Release Notes from Milestone

# Child pipeline to package the build artifacts to 'App Source' package using 'pac deploy' commands.
- template: prepare-appsource-release.yml
  parameters:
    projectName: '${{parameters.projectName}}'
    solutionsFolderPath: '$(Pipeline.Workspace)\releaseassets'
    packageFileName: '${{parameters.solutionName}}Package.zip'
    appSourceFolderName: 'Microsoft_${{parameters.solutionName}}Package'
    packageDeployerProjectName: 'PowerCAT.PackageDeployer.Package'
    pdProjectPath: '$(Build.SourcesDirectory)\${{parameters.projectName}}\PowerCAT.PackageDeployer.Package'
    generateAppSourcePackage: '${{parameters.prepareAppSourcePackage}}'  
    generatePackageDeployerPackage: '${{parameters.preparePackageDeployerPackage}}'
    packageConfigFilePath: '${{parameters.packageConfigurationFilePath}}'

- task: PowerShell@2
  displayName: 'Validate Release Notes and Assets Paths'
  inputs:
    targetType: 'inline'
    script: |
      # Validate Release Notes Path
      $releaseNotesPath = '$(ReleaseNotesPath)'

      if (-not (Test-Path $releaseNotesPath)) {
        Write-Error "Release Notes Path '$releaseNotesPath' does not exist."
        exit 1
      }
      else {
        Write-Host "Release Notes Path '$releaseNotesPath' is valid."
      }

      # Validate Assets Path
      $assetsPath = '$(Pipeline.Workspace)/releaseassets'

      if (-not (Test-Path $assetsPath)) {
        Write-Error "Assets Path '$assetsPath' does not exist or is empty."
        exit 1
      }
      else {
        # Check if files exist in the directory
        $files = Get-ChildItem -Path "$assetsPath/*.*"
        if ($files.Count -eq 0) {
          Write-Error "No files found in Assets Path '$assetsPath'."
          exit 1
        }
        else {
          Write-Host "Assets Path '$assetsPath' is valid and contains the following files:"
          # Print the file names
          foreach ($file in $files) {
            Write-Host $file.FullName
          }
        }
      }

- task: PowerShell@2
  displayName: 'Log the Tag Value'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Tag value: $(Tag)"

# Check the current directory and repository
- task: PowerShell@2
  displayName: 'Check Current Directory and Repository'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Current Directory - $(System.DefaultWorkingDirectory)"
      if (Test-Path "$(System.DefaultWorkingDirectory)/.git") {
        Write-Host ".git folder found. Repository is checked out correctly."
      }
      else {
        Write-Host "No .git folder found in the current directory."
      }

# Step to check if the tag exists and create it if it doesn't
- task: PowerShell@2
  displayName: 'Create Git Tag if not exists'
  inputs:
    targetType: 'inline'
    script: |
      $tag = '$(Tag)'
      $tagExists = git tag --list $tag

      if (-not $tagExists) {
        Write-Host "Tag '$tag' does not exist. Creating a new tag."
        git tag $tag
        git push origin $tag
      }
      else {
        Write-Host "Tag '$tag' already exists."
    workingDirectory: $(System.DefaultWorkingDirectory)

# GitHub Release Task
- task: GitHubRelease@1
  inputs:
    gitHubConnection: ${{ parameters.connectionName }}
    tag: $(Tag)
    title: $(Title)
    releaseNotesFilePath: '$(ReleaseNotesPath)'
    addChangeLog: false
    isDraft: ${{ parameters.isDraft }}
    isPreRelease: ${{ parameters.isPreRelease }}
    assets: |
      $(Pipeline.Workspace)/releaseassets/*.*
  displayName: 'Create ${{ parameters.solutionDisplayName }} Release'

# - task: GitHubRelease@1
#   inputs:
#     gitHubConnection: ${{ parameters.connectionName }}
#     tagSource: 'userSpecifiedTag'
#     tag: $(Tag)
#     title: $(Title)
#     releaseNotesFilePath: '$(ReleaseNotesPath)'
#     addChangeLog: false #The OOB changelog doesn't allow for filtering based on milestone so we created our own changelog above
#     isDraft: ${{ parameters.isDraft }}
#     isPreRelease: ${{ parameters.isPreRelease }}
#     assets: |
#       $(Pipeline.Workspace)/releaseassets/*.*
#   displayName: 'Create ${{ parameters.solutionDisplayName }} Release'